import OpenAI from 'openai';
import dotenv from 'dotenv';
import axios from 'axios';

dotenv.config();

// AI Provider configuration
const AI_PROVIDER = process.env.AI_PROVIDER || 'openai'; // Options: 'openai', 'openrouter', 'ollama'

// Initialize OpenAI with API key if using OpenAI
const openaiApiKey = process.env.OPENAI_API_KEY;
if (AI_PROVIDER === 'openai' && !openaiApiKey) {
  console.warn('OPENAI_API_KEY is not defined in environment variables. Using fallback or another provider.');
}

// Initialize OpenAI client if using OpenAI
const openai = AI_PROVIDER === 'openai' ? new OpenAI({
  apiKey: openaiApiKey
}) : null;

// OpenRouter configuration (offers free models)
const openrouterApiKey = process.env.OPENROUTER_API_KEY || 'sk-or-v1-free-tier';
const OPENROUTER_URL = 'https://openrouter.ai/api/v1/chat/completions';
// Select the best free model available on OpenRouter
const OPENROUTER_MODEL = process.env.OPENROUTER_MODEL || 'mistralai/mistral-7b-instruct'; // Good free option

// Ollama configuration (completely free, locally hosted)
const OLLAMA_URL = process.env.OLLAMA_URL || 'http://localhost:11434/api';
const OLLAMA_MODEL = process.env.OLLAMA_MODEL || 'llama2';

/**
 * Generate a basic summary when AI is not available
 * @param content Text to summarize
 * @returns A basic summary of the content
 */
const generateBasicSummary = (content: string): string => {
  console.log('Using fallback summary generation mechanism...');
  
  // Extract content, focus on first part where key info often appears
  const trimmedContent = content.length > 10000 
    ? content.substring(0, 10000) 
    : content;
  
  // Extract paragraphs and remove empty ones
  const paragraphs = trimmedContent
    .split('\n')
    .filter((p: string) => p.trim().length > 0)
    .slice(0, 10); // Take first 10 non-empty paragraphs
  
  // Create bullet points from paragraphs
  const bulletPoints = paragraphs
    .map((p: string) => p.trim())
    .map((p: string) => `• ${p.length > 200 ? p.substring(0, 200) + '...' : p}`)
    .join('\n\n');
  
  return `## Summary (Generated by fallback system)\n\n${bulletPoints}\n\n*Note: This is an automatic summary generated when AI services were unavailable. It may not be as comprehensive as an AI-generated summary.*`;
};

/**
 * Generate flashcards using basic rules when AI is not available
 * @param content Text to generate flashcards from
 * @returns Array of basic question-answer pairs
 */
const generateBasicFlashcards = (content: string): Array<{ question: string; answer: string }> => {
  console.log('Using fallback flashcard generation mechanism...');
  
  // Extract content
  const trimmedContent = content.length > 10000 
    ? content.substring(0, 10000) 
    : content;
  
  // Split into paragraphs and filter out empty ones
  const paragraphs = trimmedContent
    .split('\n')
    .filter((p: string) => p.trim().length > 0 && p.trim().length > 50)
    .slice(0, 10); // Take first 10 substantial paragraphs
  
  // Create simple flashcards based on paragraphs
  const flashcards = paragraphs.map((paragraph: string, index: number) => {
    // Use paragraph or sections if available
    const text = paragraph.trim();
    let question: string, answer: string;
    
    // If text contains a question mark, try to split on it
    if (text.includes('?')) {
      const parts = text.split('?');
      question = parts[0].trim() + '?';
      answer = parts.slice(1).join(' ').trim();
    } else if (text.includes(':')) {
      // Try to use colon as separator if present
      const parts = text.split(':');
      question = parts[0].trim() + '?';
      answer = parts.slice(1).join(' ').trim();
    } else {
      // Create a generic question from paragraph
      question = `What is the key point in paragraph ${index + 1}?`;
      answer = text.length > 200 ? text.substring(0, 200) + '...' : text;
    }
    
    return {
      question,
      answer: answer || "Information not available in this section."
    };
  });
  
  return flashcards;
};

/**
 * Try to generate a summary using OpenRouter API (with free models)
 * @param content Text to summarize
 * @returns Summary text
 */
const generateOpenRouterSummary = async (content: string): Promise<string> => {
  try {
    console.log('Using OpenRouter for summary generation...');
    const trimmedContent = content.length > 8000 
      ? content.substring(0, 8000) + '...' 
      : content;

    // Log which model we're using
    console.log(`Using OpenRouter model: ${OPENROUTER_MODEL}`);

    // Improved prompt structure for better results
    const systemPrompt = "You are a professional study assistant that creates concise, clear summaries. Extract key concepts, definitions, and main points. Format your response as bullet points for easy review.";
    
    const response = await axios.post(
      OPENROUTER_URL,
      {
        model: OPENROUTER_MODEL,
        messages: [
          {
            role: 'system',
            content: systemPrompt
          },
          {
            role: 'user',
            content: `Please summarize the following text in bullet points for easy revision:\n\n${trimmedContent}`
          }
        ],
        temperature: 0.2, // Lower temperature for more focused summaries
        max_tokens: 1500, // Allow for longer summaries
        top_p: 0.9
      },
      {
        headers: {
          'Authorization': `Bearer ${openrouterApiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://studysmartbuddy.com', // Replace with your actual domain
          'X-Title': 'StudySmartBuddy'
        },
        timeout: 60000 // 60 second timeout
      }
    );

    if (!response.data || !response.data.choices || !response.data.choices[0] || !response.data.choices[0].message) {
      throw new Error('Invalid response format from OpenRouter');
    }

    let summary = response.data.choices[0].message.content?.trim() || '';
    
    // Format the summary if it's not already in bullet points
    if (!summary.includes('•') && !summary.includes('-') && !summary.includes('*')) {
      // Convert paragraphs into bullet points
      const paragraphs = summary.split('\n\n').filter((p: string) => p.trim().length > 0);
      summary = paragraphs.map((p: string) => `• ${p.trim()}`).join('\n\n');
    }

    return summary;
  } catch (error: any) {
    console.error('OpenRouter API error:', error?.response?.data || error.message);
    return generateBasicSummary(content);
  }
};

/**
 * Try to generate flashcards using OpenRouter API
 * @param content Text to generate flashcards from
 * @returns Array of question-answer pairs
 */
const generateOpenRouterFlashcards = async (content: string): Promise<Array<{ question: string; answer: string }>> => {
  try {
    console.log('Using OpenRouter for flashcard generation...');
    const trimmedContent = content.length > 8000 
      ? content.substring(0, 8000) + '...' 
      : content;

    // Log which model we're using
    console.log(`Using OpenRouter model: ${OPENROUTER_MODEL}`);

    // Improved prompt structure for better results
    const systemPrompt = "You are a flashcard creation assistant that helps students learn efficiently. Create focused question-answer pairs that test key concepts from the provided text. Each flashcard should have a clear question and a concise answer.";
    
    const response = await axios.post(
      OPENROUTER_URL,
      {
        model: OPENROUTER_MODEL,
        messages: [
          {
            role: 'system',
            content: systemPrompt
          },
          {
            role: 'user',
            content: `Create 10 good flashcards from this text that capture key concepts and definitions:\n\n${trimmedContent}\n\nReturn them as a list using 'Question:' and 'Answer:' for each card. Format the flashcards like this:\n\nQuestion: First question?\nAnswer: First answer\n\nQuestion: Second question?\nAnswer: Second answer`
          }
        ],
        temperature: 0.3,
        max_tokens: 2000,
        top_p: 0.9
      },
      {
        headers: {
          'Authorization': `Bearer ${openrouterApiKey}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://studysmartbuddy.com', // Replace with your domain
          'X-Title': 'StudySmartBuddy'
        },
        timeout: 90000 // 90 second timeout
      }
    );

    if (!response.data || !response.data.choices || !response.data.choices[0] || !response.data.choices[0].message) {
      throw new Error('Invalid response format from OpenRouter');
    }

    const responseText = response.data.choices[0].message.content?.trim() || '';
    console.log('Received response from OpenRouter, extracting flashcards...');

    // Extract question-answer pairs using regex pattern
    const flashcards = extractQuestionAnswerPairs(responseText);
    
    if (flashcards.length > 0) {
      return flashcards;
    }
    
    // Try to parse JSON if Q&A format wasn't found
    try {
      const jsonMatch = responseText.match(/\[\s*\{.*\}\s*\]/s);
      if (jsonMatch) {
        const jsonString = jsonMatch[0];
        const parsedJson = JSON.parse(jsonString);
        
        if (Array.isArray(parsedJson) && parsedJson.length > 0 && 
            typeof parsedJson[0].question === 'string' && 
            typeof parsedJson[0].answer === 'string') {
          return parsedJson;
        }
      }
    } catch (jsonError) {
      console.log('JSON parsing failed, using extracted Q&A pairs');
    }
    
    // If all parsing failed, return basic flashcards
    return generateBasicFlashcards(content);
  } catch (error: any) {
    console.error('OpenRouter API error:', error?.response?.data || error.message);
    return generateBasicFlashcards(content);
  }
};

/**
 * Try to generate a summary using locally hosted Ollama (completely free)
 * @param content Text to summarize
 * @returns Summary text
 */
const generateOllamaSummary = async (content: string): Promise<string> => {
  try {
    console.log('Using Ollama for summary generation...');
    const trimmedContent = content.length > 4000 
      ? content.substring(0, 4000) + '...' 
      : content;

    // Enhanced prompt structure for phi3 models
    const prompt = `<|system|>
You are a highly skilled study assistant that helps create concise, clear summaries of academic content. 
Focus on extracting key concepts, definitions, and main points.
Create bullet points that are easy to understand and review.
<|user|>
Please summarize the following text in bullet points for easy revision:

${trimmedContent}
<|assistant|>`;

    console.log(`Sending request to Ollama (${OLLAMA_MODEL}) for summary generation...`);

    const response = await axios.post(
      `${OLLAMA_URL}/generate`,
      {
        model: OLLAMA_MODEL,
        prompt,
        stream: false,
        options: {
          temperature: 0.1, // Lower temperature for more focused summaries
          top_p: 0.9,
          num_predict: 1024 // Limit the length of the response
        }
      },
      {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 60000 // 60 seconds timeout
      }
    );

    if (!response.data || !response.data.response) {
      throw new Error('Empty response from Ollama');
    }

    // Clean up the response - sometimes the model includes unnecessary prefixes or formatting
    let summary = response.data.response.trim();
    
    // Format the summary if it's not already in bullet points
    if (!summary.includes('•') && !summary.includes('-')) {
      // Convert paragraphs into bullet points
      const paragraphs = summary.split('\n\n').filter((p: string) => p.trim().length > 0);
      summary = paragraphs.map((p: string) => `• ${p.trim()}`).join('\n\n');
    }

    return summary;
  } catch (error: any) {
    console.error('Ollama API error:', error?.response?.data || error.message);
    return generateBasicSummary(content);
  }
};

/**
 * Try to generate flashcards using locally hosted Ollama
 * @param content Text to generate flashcards from
 * @returns Array of question-answer pairs
 */
const generateOllamaFlashcards = async (content: string): Promise<Array<{ question: string; answer: string }>> => {
  try {
    console.log('Using Ollama for flashcard generation...');
    const trimmedContent = content.length > 4000 
      ? content.substring(0, 4000) + '...' 
      : content;

    // Enhanced prompt structure for phi3 models
    const prompt = `<|system|>
You are a flashcard creation assistant that helps students learn efficiently. 
Create question-answer pairs that test key concepts from the provided text.
Each flashcard should have a clear question and a concise answer.
Return 10 flashcards in valid JSON format with an array of objects containing "question" and "answer" fields.
<|user|>
Based on the following text, generate a list of flashcards in JSON format:

${trimmedContent}

Return exactly this format:
[
  {"question": "First question?", "answer": "First answer"},
  {"question": "Second question?", "answer": "Second answer"},
  ...
]
<|assistant|>`;

    console.log(`Sending request to Ollama (${OLLAMA_MODEL}) for flashcard generation...`);

    const response = await axios.post(
      `${OLLAMA_URL}/generate`,
      {
        model: OLLAMA_MODEL,
        prompt,
        stream: false,
        options: {
          temperature: 0.2, // Slightly higher for creative questions
          top_p: 0.9,
          num_predict: 2048 // Allow longer response for multiple flashcards
        }
      },
      {
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: 90000 // 90 seconds timeout for flashcard generation
      }
    );

    if (!response.data || !response.data.response) {
      throw new Error('Empty response from Ollama');
    }

    const responseText = response.data.response.trim();
    console.log('Received response from Ollama, extracting JSON...');

    try {
      // Try to extract JSON array from the response using regex
      const jsonMatch = responseText.match(/\[\s*\{.*\}\s*\]/s);
      if (jsonMatch) {
        const jsonString = jsonMatch[0];
        const parsedResponse = JSON.parse(jsonString);
        
        if (Array.isArray(parsedResponse) && parsedResponse.length > 0) {
          // Validate that each item has question and answer
          const validFlashcards = parsedResponse
            .filter((card: { question: string; answer: string }) => card && typeof card.question === 'string' && typeof card.answer === 'string')
            .map((card: { question: string; answer: string }) => ({
              question: card.question.trim().endsWith('?') ? card.question.trim() : `${card.question.trim()}?`,
              answer: card.answer.trim()
            }));
          
          if (validFlashcards.length > 0) {
            return validFlashcards;
          }
        }
      }
      
      // If JSON extraction failed, try another approach by finding question-answer pairs
      const pairs = extractQuestionAnswerPairs(responseText);
      if (pairs.length > 0) {
        return pairs;
      }
      
      throw new Error('Could not parse valid flashcards from response');
    } catch (parseError) {
      console.error('Error parsing Ollama response:', parseError);
      console.log('Raw response:', responseText);
      throw parseError;
    }
  } catch (error: any) {
    console.error('Ollama API error or parsing error:', error?.response?.data || error.message);
    return generateBasicFlashcards(content);
  }
};

/**
 * Helper function to extract question-answer pairs from text when JSON parsing fails
 */
function extractQuestionAnswerPairs(text: string): Array<{ question: string; answer: string }> {
  const pairs: Array<{ question: string; answer: string }> = [];
  
  // Look for "Question: ... Answer: ..." patterns
  const qaRegex = /(?:Question|Q):\s*([^\n?]+\??)\s*(?:Answer|A):\s*([^\n]+)/gi;
  let match: RegExpExecArray | null;
  
  while ((match = qaRegex.exec(text)) !== null) {
    if (match[1] && match[2]) {
      const question = match[1].trim().endsWith('?') ? match[1].trim() : `${match[1].trim()}?`;
      pairs.push({
        question,
        answer: match[2].trim()
      });
    }
  }
  
  // If no matches, look for lines ending with question marks
  if (pairs.length === 0) {
    const lines = text.split('\n').filter((line: string) => line.trim().length > 0);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line.endsWith('?') && i + 1 < lines.length) {
        pairs.push({
          question: line,
          answer: lines[i + 1].trim()
        });
        i++; // Skip the next line as we've used it as an answer
      }
    }
  }
  
  return pairs;
}

/**
 * Generate a summary from text content based on configured AI provider
 * @param content The text content to summarize
 * @returns A summarized version of the content
 */
export const generateSummary = async (content: string): Promise<string> => {
  if (!content || content.trim().length === 0) {
    return "No content provided to summarize.";
  }

  // Choose the appropriate AI provider based on configuration
  try {
    console.log(`Using ${AI_PROVIDER} as the AI provider for summary generation...`);

    switch (AI_PROVIDER) {
      case 'openai':
        return await generateOpenAISummary(content);
      case 'openrouter':
        return await generateOpenRouterSummary(content);
      case 'ollama':
        return await generateOllamaSummary(content);
      default:
        console.warn(`Unknown AI provider ${AI_PROVIDER}, using fallback summary generation.`);
        return generateBasicSummary(content);
    }
  } catch (error: any) {
    console.error('Error generating summary:', error);
    return generateBasicSummary(content);
  }
};

/**
 * Generate flashcards from text content based on configured AI provider
 * @param content The text content to generate flashcards from
 * @returns An array of question-answer pairs
 */
export const generateFlashcards = async (content: string): Promise<Array<{ question: string; answer: string }>> => {
  if (!content || content.trim().length === 0) {
    return [];
  }

  // Choose the appropriate AI provider based on configuration
  try {
    console.log(`Using ${AI_PROVIDER} as the AI provider for flashcard generation...`);

    switch (AI_PROVIDER) {
      case 'openai':
        return await generateOpenAIFlashcards(content);
      case 'openrouter':
        return await generateOpenRouterFlashcards(content);
      case 'ollama':
        return await generateOllamaFlashcards(content);
      default:
        console.warn(`Unknown AI provider ${AI_PROVIDER}, using fallback flashcard generation.`);
        return generateBasicFlashcards(content);
    }
  } catch (error: any) {
    console.error('Error generating flashcards:', error);
    return generateBasicFlashcards(content);
  }
};

/**
 * Original OpenAI implementation for summary generation
 */
async function generateOpenAISummary(content: string): Promise<string> {
  try {
    // Check if API key is missing, use fallback if it is
    if (!openaiApiKey || !openai) {
      console.warn('OpenAI API key is missing, using fallback summary generation.');
      return generateBasicSummary(content);
    }

    // Limit content length to avoid token limits
    const trimmedContent = content.length > 10000 
      ? content.substring(0, 10000) + '...' 
      : content;

    const prompt = `You're a study assistant. Summarize the following text in bullet points for easy revision:
    
    ${trimmedContent}`;

    console.log('Sending request to OpenAI API for summary generation...');
    
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 1000,
      temperature: 0.3,
    });

    const summaryText = completion.choices[0]?.message?.content;
    
    if (!summaryText) {
      throw new Error('OpenAI returned empty summary response');
    }
    
    return summaryText;
  } catch (error: any) {
    console.error('Error in OpenAI summary generation:', error);
    
    // If we hit rate limits or other OpenAI API issues, use fallback
    if (
      error.status === 429 || 
      error.code === 'insufficient_quota' || 
      error.type === 'insufficient_quota' ||
      error.status === 500 || 
      error.status === 503 ||
      (error.message && error.message.includes('quota'))
    ) {
      console.warn('OpenAI API quota exceeded or service unavailable. Using fallback summary generation.');
      return generateBasicSummary(content);
    }
    
    throw error;
  }
}

/**
 * Original OpenAI implementation for flashcard generation
 */
async function generateOpenAIFlashcards(content: string): Promise<Array<{ question: string; answer: string }>> {
  try {
    // Check if API key is missing, use fallback if it is
    if (!openaiApiKey || !openai) {
      console.warn('OpenAI API key is missing, using fallback flashcard generation.');
      return generateBasicFlashcards(content);
    }
    
    // Limit content length to avoid token limits
    const trimmedContent = content.length > 10000 
      ? content.substring(0, 10000) + '...' 
      : content;

    const prompt = `Based on the following text, generate a list of Q&A flashcards:
    
    ${trimmedContent}
    
    Return the output in JSON with format:
    [{ "question": "...", "answer": "..." }]`;

    console.log('Sending request to OpenAI API for flashcard generation...');

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 1500,
      temperature: 0.3,
      response_format: { type: "json_object" }
    });

    const responseContent = completion.choices[0]?.message?.content;
    if (!responseContent) {
      throw new Error('OpenAI returned empty flashcard response');
    }
    
    console.log('Received response from OpenAI API, parsing JSON...');
    
    try {
      const parsedResponse = JSON.parse(responseContent);
      
      // Ensure we have a cards array in the response
      if (Array.isArray(parsedResponse.cards)) {
        return parsedResponse.cards;
      } else if (Array.isArray(parsedResponse)) {
        return parsedResponse;
      } else {
        console.error('Unexpected response format:', responseContent);
        return [];
      }
    } catch (parseError: any) {
      console.error('Error parsing JSON response:', parseError);
      console.error('Raw response:', responseContent);
      throw new Error(`Failed to parse flashcard data: ${parseError.message}`);
    }
  } catch (error: any) {
    console.error('Error in OpenAI flashcard generation:', error);
    
    // If we hit rate limits or other OpenAI API issues, use fallback
    if (
      error.status === 429 || 
      error.code === 'insufficient_quota' || 
      error.type === 'insufficient_quota' ||
      error.status === 500 || 
      error.status === 503 ||
      (error.message && error.message.includes('quota'))
    ) {
      console.warn('OpenAI API quota exceeded or service unavailable. Using fallback flashcard generation.');
      return generateBasicFlashcards(content);
    }
    
    throw error;
  }
}

export default {
  generateSummary,
  generateFlashcards
};