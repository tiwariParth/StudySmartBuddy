import OpenAI from 'openai';
import dotenv from 'dotenv';

dotenv.config();

// Initialize OpenAI with better error handling for the API key
const apiKey = process.env.OPENAI_API_KEY;
if (!apiKey) {
  console.error('OPENAI_API_KEY is not defined in environment variables');
}

const openai = new OpenAI({
  apiKey
});

/**
 * Generate a basic summary when AI is not available
 * @param content Text to summarize
 * @returns A basic summary of the content
 */
const generateBasicSummary = (content: string): string => {
  console.log('Using fallback summary generation mechanism...');
  
  // Extract content, focus on first part where key info often appears
  const trimmedContent = content.length > 10000 
    ? content.substring(0, 10000) 
    : content;
  
  // Extract paragraphs and remove empty ones
  const paragraphs = trimmedContent
    .split('\n')
    .filter(p => p.trim().length > 0)
    .slice(0, 10); // Take first 10 non-empty paragraphs
  
  // Create bullet points from paragraphs
  const bulletPoints = paragraphs
    .map(p => p.trim())
    .map(p => `â€¢ ${p.length > 200 ? p.substring(0, 200) + '...' : p}`)
    .join('\n\n');
  
  return `## Summary (Generated by fallback system)\n\n${bulletPoints}\n\n*Note: This is an automatic summary generated when AI services were unavailable. It may not be as comprehensive as an AI-generated summary.*`;
};

/**
 * Generate flashcards using basic rules when AI is not available
 * @param content Text to generate flashcards from
 * @returns Array of basic question-answer pairs
 */
const generateBasicFlashcards = (content: string): Array<{ question: string; answer: string }> => {
  console.log('Using fallback flashcard generation mechanism...');
  
  // Extract content
  const trimmedContent = content.length > 10000 
    ? content.substring(0, 10000) 
    : content;
  
  // Split into paragraphs and filter out empty ones
  const paragraphs = trimmedContent
    .split('\n')
    .filter(p => p.trim().length > 0 && p.trim().length > 50)
    .slice(0, 10); // Take first 10 substantial paragraphs
  
  // Create simple flashcards based on paragraphs
  const flashcards = paragraphs.map((paragraph, index) => {
    // Use paragraph or sections if available
    const text = paragraph.trim();
    let question, answer;
    
    // If text contains a question mark, try to split on it
    if (text.includes('?')) {
      const parts = text.split('?');
      question = parts[0].trim() + '?';
      answer = parts.slice(1).join(' ').trim();
    } else if (text.includes(':')) {
      // Try to use colon as separator if present
      const parts = text.split(':');
      question = parts[0].trim() + '?';
      answer = parts.slice(1).join(' ').trim();
    } else {
      // Create a generic question from paragraph
      question = `What is the key point in paragraph ${index + 1}?`;
      answer = text.length > 200 ? text.substring(0, 200) + '...' : text;
    }
    
    return {
      question,
      answer: answer || "Information not available in this section."
    };
  });
  
  return flashcards;
};

/**
 * Generate a summary from text content
 * @param content The text content to summarize
 * @returns A summarized version of the content
 */
export const generateSummary = async (content: string): Promise<string> => {
  try {
    if (!content || content.trim().length === 0) {
      return "No content provided to summarize.";
    }

    // Check if API key is missing, use fallback if it is
    if (!apiKey) {
      console.warn('OpenAI API key is missing, using fallback summary generation.');
      return generateBasicSummary(content);
    }

    // Limit content length to avoid token limits
    const trimmedContent = content.length > 10000 
      ? content.substring(0, 10000) + '...' 
      : content;

    const prompt = `You're a study assistant. Summarize the following text in bullet points for easy revision:
    
    ${trimmedContent}`;

    console.log('Sending request to OpenAI API for summary generation...');
    
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 1000,
      temperature: 0.3,
    });

    const summaryText = completion.choices[0]?.message?.content;
    
    if (!summaryText) {
      throw new Error('OpenAI returned empty summary response');
    }
    
    return summaryText;
  } catch (error: any) {
    console.error('Error generating summary:', error);
    
    // If we hit rate limits or other OpenAI API issues, use fallback
    if (
      error.status === 429 || // Rate limit
      error.code === 'insufficient_quota' || 
      error.type === 'insufficient_quota' ||
      error.status === 500 || // Server error
      error.status === 503 || // Service unavailable
      (error.message && error.message.includes('quota')) // Any quota-related messages
    ) {
      console.warn('OpenAI API quota exceeded or service unavailable. Using fallback summary generation.');
      return generateBasicSummary(content);
    }
    
    // For other errors, provide more specific error messages
    if (error.response) {
      console.error('OpenAI API error status:', error.response.status);
      console.error('OpenAI API error data:', error.response.data);
      throw new Error(`OpenAI API error: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
    }
    
    throw new Error(`Failed to generate summary: ${error.message || 'Unknown error'}`);
  }
};

/**
 * Generate flashcards from text content
 * @param content The text content to generate flashcards from
 * @returns An array of question-answer pairs
 */
export const generateFlashcards = async (content: string): Promise<Array<{ question: string; answer: string }>> => {
  try {
    if (!content || content.trim().length === 0) {
      throw new Error('No content provided to generate flashcards from.');
    }
    
    // Check if API key is missing, use fallback if it is
    if (!apiKey) {
      console.warn('OpenAI API key is missing, using fallback flashcard generation.');
      return generateBasicFlashcards(content);
    }
    
    // Limit content length to avoid token limits
    const trimmedContent = content.length > 10000 
      ? content.substring(0, 10000) + '...' 
      : content;

    const prompt = `Based on the following text, generate a list of Q&A flashcards:
    
    ${trimmedContent}
    
    Return the output in JSON with format:
    [{ "question": "...", "answer": "..." }]`;

    console.log('Sending request to OpenAI API for flashcard generation...');

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 1500,
      temperature: 0.3,
      response_format: { type: "json_object" }
    });

    const responseContent = completion.choices[0]?.message?.content;
    if (!responseContent) {
      throw new Error('OpenAI returned empty flashcard response');
    }
    
    console.log('Received response from OpenAI API, parsing JSON...');
    
    try {
      const parsedResponse = JSON.parse(responseContent);
      
      // Ensure we have a cards array in the response
      if (Array.isArray(parsedResponse.cards)) {
        return parsedResponse.cards;
      } else if (Array.isArray(parsedResponse)) {
        return parsedResponse;
      } else {
        console.error('Unexpected response format:', responseContent);
        return [];
      }
    } catch (parseError: any) {
      console.error('Error parsing JSON response:', parseError);
      console.error('Raw response:', responseContent);
      throw new Error(`Failed to parse flashcard data: ${parseError.message}`);
    }
  } catch (error: any) {
    console.error('Error generating flashcards:', error);
    
    // If we hit rate limits or other OpenAI API issues, use fallback
    if (
      error.status === 429 || // Rate limit
      error.code === 'insufficient_quota' || 
      error.type === 'insufficient_quota' ||
      error.status === 500 || // Server error
      error.status === 503 || // Service unavailable
      (error.message && error.message.includes('quota')) // Any quota-related messages
    ) {
      console.warn('OpenAI API quota exceeded or service unavailable. Using fallback flashcard generation.');
      return generateBasicFlashcards(content);
    }
    
    // For other errors, provide more specific error messages
    if (error.response) {
      console.error('OpenAI API error status:', error.response.status);
      console.error('OpenAI API error data:', error.response.data);
      throw new Error(`OpenAI API error: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
    }
    
    throw new Error(`Failed to generate flashcards: ${error.message || 'Unknown error'}`);
  }
};

export default {
  generateSummary,
  generateFlashcards
};